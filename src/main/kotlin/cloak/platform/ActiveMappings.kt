package cloak.platform

import cloak.format.descriptor.ParameterDescriptor
import cloak.format.descriptor.remap
import cloak.format.mappings.*
import cloak.format.rename.*
import cloak.git.yarnRepo
import cloak.idea.NamingProgress
import cloak.platform.saved.isAutogenerated
import java.io.File


object ActiveMappings {
    private var activeMappings: MutableMap<Name, NamingProgress> = mutableMapOf()
    private var intermediaryToNamed: MutableMap<String, String> = mutableMapOf()

    fun areActive() = activeMappings.isNotEmpty()

    fun getProgressOf(name: Name, platform: ExtendedPlatform, mcJar: File): NamingProgress {
        val progressInActiveMappings = activeMappings[name]
        return when {
            name is FieldName && platform.isAutogenerated(name, mcJar) -> NamingProgress.AutoGenerated
            progressInActiveMappings != null -> progressInActiveMappings
            name.isInIntermediary() -> NamingProgress.Unnamed
            else -> NamingProgress.NamedInLaterVersion
        }

    }

    private fun Name.isInIntermediary() = when (this) {
        is ClassName -> className.startsWith("class_")
        is FieldName -> fieldName.startsWith("field_")
        is MethodName -> methodName.startsWith("method_")
        is ParamName -> true // Not technically in intermediary but we want to show unnamed in the case of params
    }

    private fun Mapping.addAsName(intToNamedMappingsAlreadyExist: Boolean): Name {
        val deobfName = deobfNameInTinyMappings()
        if (deobfName != null) {
            intermediaryToNamed[obfNameInTinyMappings()] = deobfName
        }

        val name = when (this) {
            is ClassMapping -> ClassName(
                classIn = parent?.addAsName(intToNamedMappingsAlreadyExist) as? ClassName,
                className = displayedName.split("/").last(),
                packageName = packageName
            )
            is MethodMapping -> MethodName(
                classIn = parent.addAsName(intToNamedMappingsAlreadyExist) as ClassName,
                methodName = displayedName,
                parameterTypes = descriptor.parameterDescriptors
                    // If this is the first time getting the mappings then the int -> named mappings are not ready yet
                    // and we only remap them after adding all the mappings is done
                    .let { if (intToNamedMappingsAlreadyExist) it.remapToNamed() else it }
            )
            is FieldMapping -> FieldName(
                fieldName = displayedName,
                classIn = parent.addAsName(intToNamedMappingsAlreadyExist) as ClassName
            )
            is ParameterMapping -> ParamName(
                paramName = displayedName,
                methodIn = parent.addAsName(intToNamedMappingsAlreadyExist) as MethodName,
                index = index
            )
        }

        activeMappings[name] = when {
            deobfuscatedName == null -> NamingProgress.Unnamed
            comment.isEmpty() -> NamingProgress.NamedWithoutJavadoc
            else -> NamingProgress.NamedWithJavadoc
        }



        return name
    }


    private fun MappingsFile.addAllNames(intToNamedMappingsAlreadyExist: Boolean) =
        visit { it.addAsName(intToNamedMappingsAlreadyExist) }

    fun deactivate() {
        activeMappings = mutableMapOf()
    }

    private fun List<ParameterDescriptor>.remapToNamed() = map { it.remap(::intermediaryToNamedMapping) }

    private fun MethodName.remapParamsToNamed() = copy(parameterTypes = parameterTypes.remapToNamed())
    fun refresh(platform: ExtendedPlatform) {
        val yarn = platform.yarnRepo
        activeMappings = mutableMapOf()
        intermediaryToNamed = mutableMapOf()
        yarn.getMappingsFilesLocations()
            .forEach {
                it to MappingsFile.read(yarn.getMappingsFile(it + MappingsExtension))
                    .addAllNames(intToNamedMappingsAlreadyExist = false)
            }

        // Remap methods from intermediary to named because mappings files have them in int and the user sees them as named
        activeMappings = activeMappings.mapKeys { (name, _) ->
            when (name) {
                is MethodName -> name.remapParamsToNamed()
                is ParamName -> name.copy(methodIn = name.methodIn.remapParamsToNamed())
                else -> name
            }
        }.toMutableMap()

    }

    private fun intermediaryToNamedMapping(name: String): String? = intermediaryToNamed[name]

    fun update(newMappings: MappingsFile) {
        newMappings.addAllNames(intToNamedMappingsAlreadyExist = true)
    }
}